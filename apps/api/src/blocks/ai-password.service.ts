import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../shared/database/prisma.service';
import { BlocksService } from './blocks.service';
import { DifficultyConfig } from '../shared/utils/types';

@Injectable()
export class AiPasswordService {
  private readonly logger = new Logger(AiPasswordService.name);
  private readonly openaiApiKey: string;

  constructor(
    private readonly configService: ConfigService,
    private readonly prisma: PrismaService,
    private readonly blocksService: BlocksService,
  ) {
    this.openaiApiKey = this.configService.get<string>('openai.apiKey') || '';
  }

  async attemptPasswordGeneration(blockId: bigint): Promise<boolean> {
    try {
      const block = await this.prisma.block.findUnique({
        where: { id: blockId },
        select: {
          id: true,
          seedHint: true,
          difficultyConfig: true,
          passwordRetryCount: true,
        },
      });

      if (!block) {
        this.logger.error(`Block ${blockId} not found`);
        return false;
      }

      const password = await this.generatePasswordWithAI(
        block.seedHint || '',
        block.difficultyConfig as any
      );

      if (!this.validatePassword(password, block.difficultyConfig as any)) {
        await this.incrementRetryCount(blockId);
        this.logger.warn(
          `Generated password for block ${blockId} failed validation`
        );
        return false;
      }

      await this.blocksService.setPassword(blockId, password);
      this.logger.log(`Successfully generated password for block ${blockId}`);
      return true;
    } catch (error) {
      await this.incrementRetryCount(blockId);
      this.logger.error(
        `Failed to generate password for block ${blockId}:`,
        error
      );
      return false;
    }
  }

  private async generatePasswordWithAI(
    hint: string,
    config: DifficultyConfig
  ): Promise<string> {
    const charsetDescription = this.getCharsetDescription(config.charset);

    const prompt = `Generate a password based on this hint: "${hint}"
Requirements:
- Exact length: ${config.length} characters
- Allowed characters: ${charsetDescription}
Return ONLY the password, no explanation.`;

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.openaiApiKey}`,
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.7,
      }),
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.statusText}`);
    }

    const data = await response.json();
    const password = data.choices[0]?.message?.content?.trim();

    if (!password) {
      throw new Error('No password generated by AI');
    }

    return password;
  }

  private validatePassword(password: string, config: DifficultyConfig): boolean {
    if (password.length !== config.length) {
      return false;
    }

    const allowedChars = this.getCharsetString(config.charset);
    return [...password].every((char) => allowedChars.includes(char));
  }

  private getCharsetString(charset: string[]): string {
    let chars = '';
    if (charset.includes('lowercase')) chars += 'abcdefghijklmnopqrstuvwxyz';
    if (charset.includes('uppercase')) chars += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    if (charset.includes('numbers')) chars += '0123456789';
    if (charset.includes('symbols')) chars += '!@#$%^&*()_+-=[]{}|;:,.<>?';
    return chars;
  }

  private getCharsetDescription(charset: string[]): string {
    const descriptions: string[] = [];
    if (charset.includes('lowercase')) descriptions.push('lowercase letters (a-z)');
    if (charset.includes('uppercase')) descriptions.push('uppercase letters (A-Z)');
    if (charset.includes('numbers')) descriptions.push('numbers (0-9)');
    if (charset.includes('symbols')) descriptions.push('symbols (!@#$%^&*...)');
    return descriptions.join(', ');
  }

  private async incrementRetryCount(blockId: bigint): Promise<void> {
    await this.prisma.block.update({
      where: { id: blockId },
      data: {
        passwordRetryCount: {
          increment: 1,
        },
      },
    });
  }
}
